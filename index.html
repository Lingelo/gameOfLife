<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Jeu de la Vie - Version Organique</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 8;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    resizeCanvas();

    const numRows = Math.floor(canvas.height / cellSize);
    const numCols = Math.floor(canvas.width / cellSize);

    let grid = Array.from({ length: numRows }, () => Array(numCols).fill(false));
    let cellAge = Array.from({ length: numRows }, () => Array(numCols).fill(0));
    let cellBrightness = Array.from({ length: numRows }, () => Array(numCols).fill(0));
    let animationTime = 0;
    let generationCount = 0;
    let lastActivityCheck = 0;
    let isPressed = false;
    let lastInjectionTime = 0;
    let currentTouchX = 0;
    let currentTouchY = 0;

    function drawGrid() {
        ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        animationTime += 0.05;
        
        const centerRow = Math.floor(numRows / 2);
        const centerCol = Math.floor(numCols / 2);
        
        const cells = [];
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                const distance = Math.sqrt((i - centerRow) ** 2 + (j - centerCol) ** 2);
                cells.push({ row: i, col: j, distance });
            }
        }
        
        cells.sort((a, b) => {
            const waveA = Math.sin(a.distance * 0.3 + animationTime * 5) + Math.random() * 0.5;
            const waveB = Math.sin(b.distance * 0.3 + animationTime * 5) + Math.random() * 0.5;
            return waveA - waveB;
        });
        
        cells.forEach(cell => {
            if (grid[cell.row][cell.col]) {
                drawLiveCell(cell.row, cell.col);
            } else {
                drawDeadCell(cell.row, cell.col);
            }
        });
        
        // Effet continu si bouton/doigt pressé
        if (isPressed) {
            drawContinuousEffect(currentTouchX, currentTouchY);
            
            // Injection continue toutes les 300ms
            if (Date.now() - lastInjectionTime > 300) {
                injectLifeAtPosition(currentTouchX, currentTouchY);
                lastInjectionTime = Date.now();
            }
        }
    }

    function drawLiveCell(row, col) {
        const x = col * cellSize;
        const y = row * cellSize;
        const age = cellAge[row][col];
        const pulse = Math.sin(animationTime * 3 + row * 0.1 + col * 0.1) * 0.3 + 0.7;
        
        const hue = (age * 10 + animationTime * 20) % 360;
        const saturation = Math.min(80 + age * 2, 100);
        const lightness = Math.min(50 + age, 80) * pulse;
        
        ctx.save();
        
        const gradient = ctx.createRadialGradient(
            x + cellSize/2, y + cellSize/2, 0,
            x + cellSize/2, y + cellSize/2, cellSize/2
        );
        gradient.addColorStop(0, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        gradient.addColorStop(0.7, `hsl(${hue}, ${saturation}%, ${lightness * 0.7}%)`);
        gradient.addColorStop(1, `hsl(${hue}, ${saturation}%, ${lightness * 0.3}%)`);
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        ctx.shadowBlur = cellSize * 0.8 * pulse;
        
        const size = cellSize * (0.8 + 0.2 * pulse);
        const offset = (cellSize - size) / 2;
        
        ctx.beginPath();
        ctx.arc(x + cellSize/2, y + cellSize/2, size/2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    function drawDeadCell(row, col) {
        const neighbors = countNeighbors(row, col);
        if (neighbors > 0) {
            const x = col * cellSize;
            const y = row * cellSize;
            const alpha = Math.min(neighbors * 0.1, 0.3);
            
            ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
            ctx.fillRect(x + cellSize/4, y + cellSize/4, cellSize/2, cellSize/2);
        }
    }

    function updateGrid() {
        const oldGrid = grid.map(row => [...row]);
        const newGrid = Array.from({ length: numRows }, () => Array(numCols).fill(false));
        const newCellAge = Array.from({ length: numRows }, () => Array(numCols).fill(0));
        
        let changes = 0;
        
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                const neighbors = countNeighbors(i, j);
                const currentAge = cellAge[i][j];
                
                if (grid[i][j] && (neighbors === 2 || neighbors === 3)) {
                    newGrid[i][j] = true;
                    newCellAge[i][j] = currentAge + 1;
                } else if (!grid[i][j] && neighbors === 3) {
                    newGrid[i][j] = true;
                    newCellAge[i][j] = 1;
                    changes++;
                }
                
                if (oldGrid[i][j] !== newGrid[i][j]) changes++;
            }
        }
        
        grid = newGrid;
        cellAge = newCellAge;
        generationCount++;
        
    }

    function injectLifeAtPosition(mouseX, mouseY) {
        const centerCol = Math.floor(mouseX / cellSize);
        const centerRow = Math.floor(mouseY / cellSize);
        
        // Animation de clic - onde d'expansion
        createClickAnimation(mouseX, mouseY);
        
        const patterns = [
            // Glider
            [[1,0],[2,1],[0,2],[1,2],[2,2]],
            // Pulsar fragment
            [[1,0],[1,1],[1,2],[0,1]],
            // Random cluster
            [[0,0],[0,1],[1,0],[1,1],[2,1]]
        ];
        
        const pattern = patterns[Math.floor(Math.random() * patterns.length)];
        
        // Animation séquentielle d'apparition des cellules
        pattern.forEach(([r, c], index) => {
            setTimeout(() => {
                const row = centerRow + r - 1;
                const col = centerCol + c - 1;
                if (row >= 0 && row < numRows && col >= 0 && col < numCols) {
                    grid[row][col] = true;
                    cellAge[row][col] = 1;
                    
                    // Effet de matérialisation de la cellule
                    createCellBirthAnimation(row, col);
                }
            }, index * 100);
        });
    }

    function createClickAnimation(x, y) {
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                ctx.save();
                ctx.globalAlpha = 1 - (i * 0.12);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3 - (i * 0.3);
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.arc(x, y, i * 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Particules qui s'échappent
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2;
                    const px = x + Math.cos(angle) * i * 5;
                    const py = y + Math.sin(angle) * i * 5;
                    
                    ctx.fillStyle = `rgba(0, 255, 136, ${1 - (i * 0.12)})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }, i * 50);
        }
    }

    function createCellBirthAnimation(row, col) {
        const x = col * cellSize + cellSize/2;
        const y = row * cellSize + cellSize/2;
        
        for (let i = 0; i < 6; i++) {
            setTimeout(() => {
                ctx.save();
                ctx.globalAlpha = 1 - (i * 0.15);
                
                // Étoile qui pulse
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 8;
                
                const size = cellSize * (0.5 + i * 0.3);
                
                ctx.beginPath();
                for (let star = 0; star < 8; star++) {
                    const angle = (star / 8) * Math.PI * 2;
                    const radius = star % 2 === 0 ? size : size * 0.5;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    
                    if (star === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            }, i * 80);
        }
    }

    function drawContinuousEffect(x, y) {
        ctx.save();
        
        // Halo pulsant continu
        const pulse = Math.sin(animationTime * 8) * 0.5 + 0.5;
        const radius = 20 + pulse * 15;
        
        // Gradient radial animé
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(0, 255, 136, ${0.8 * pulse})`);
        gradient.addColorStop(0.5, `rgba(0, 255, 136, ${0.4 * pulse})`);
        gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Cercles concentriques animés
        for (let i = 0; i < 3; i++) {
            const ringRadius = (radius * 0.3) + (i * 8) + (pulse * 5);
            ctx.strokeStyle = `rgba(0, 255, 136, ${(1 - i * 0.3) * pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Particules orbitales
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + animationTime * 2;
            const particleRadius = radius * 0.7;
            const px = x + Math.cos(angle) * particleRadius;
            const py = y + Math.sin(angle) * particleRadius;
            
            ctx.fillStyle = `rgba(255, 170, 0, ${pulse})`;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }


    function countNeighbors(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                const newRow = row + i;
                const newCol = col + j;
                if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols && grid[newRow][newCol]) {
                    count++;
                }
            }
        }
        return count;
    }

    function initGridRandom() {
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                if (Math.random() < 0.3) {
                    grid[i][j] = true;
                    cellAge[i][j] = Math.floor(Math.random() * 10);
                }
            }
        }
    }


    function startGame() {
        initGridRandom();
        
        const gameLoop = () => {
            updateGrid();
            drawGrid();
            requestAnimationFrame(gameLoop);
        };
        
        gameLoop();
    }

    window.onload = function() {
        startGame();
        
        // Événements souris
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            currentTouchX = e.clientX - rect.left;
            currentTouchY = e.clientY - rect.top;
            isPressed = true;
            lastInjectionTime = Date.now();
            injectLifeAtPosition(currentTouchX, currentTouchY);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isPressed) {
                const rect = canvas.getBoundingClientRect();
                currentTouchX = e.clientX - rect.left;
                currentTouchY = e.clientY - rect.top;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isPressed = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isPressed = false;
        });
        
        // Événements tactiles
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            currentTouchX = touch.clientX - rect.left;
            currentTouchY = touch.clientY - rect.top;
            isPressed = true;
            lastInjectionTime = Date.now();
            injectLifeAtPosition(currentTouchX, currentTouchY);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isPressed && e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                currentTouchX = touch.clientX - rect.left;
                currentTouchY = touch.clientY - rect.top;
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isPressed = false;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isPressed = false;
        });
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            const newNumRows = Math.floor(canvas.height / cellSize);
            const newNumCols = Math.floor(canvas.width / cellSize);
            
            if (newNumRows !== numRows || newNumCols !== numCols) {
                location.reload();
            }
        });
        
        setInterval(() => {
            updateGrid();
        }, 120);
    };
</script>
</body>
</html>
