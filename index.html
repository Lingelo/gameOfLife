<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Jeu de la Vie - Version Organique</title>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 8;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    resizeCanvas();

    const numRows = Math.floor(canvas.height / cellSize);
    const numCols = Math.floor(canvas.width / cellSize);

    let grid = Array.from({ length: numRows }, () => Array(numCols).fill(false));
    let cellAge = Array.from({ length: numRows }, () => Array(numCols).fill(0));
    let cellBrightness = Array.from({ length: numRows }, () => Array(numCols).fill(0));
    let animationTime = 0;

    function drawGrid() {
        ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        animationTime += 0.05;
        
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                if (grid[i][j]) {
                    drawLiveCell(i, j);
                } else {
                    drawDeadCell(i, j);
                }
            }
        }
    }

    function drawLiveCell(row, col) {
        const x = col * cellSize;
        const y = row * cellSize;
        const age = cellAge[row][col];
        const pulse = Math.sin(animationTime * 3 + row * 0.1 + col * 0.1) * 0.3 + 0.7;
        
        const hue = (age * 10 + animationTime * 20) % 360;
        const saturation = Math.min(80 + age * 2, 100);
        const lightness = Math.min(50 + age, 80) * pulse;
        
        ctx.save();
        
        const gradient = ctx.createRadialGradient(
            x + cellSize/2, y + cellSize/2, 0,
            x + cellSize/2, y + cellSize/2, cellSize/2
        );
        gradient.addColorStop(0, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
        gradient.addColorStop(0.7, `hsl(${hue}, ${saturation}%, ${lightness * 0.7}%)`);
        gradient.addColorStop(1, `hsl(${hue}, ${saturation}%, ${lightness * 0.3}%)`);
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        ctx.shadowBlur = cellSize * 0.8 * pulse;
        
        const size = cellSize * (0.8 + 0.2 * pulse);
        const offset = (cellSize - size) / 2;
        
        ctx.beginPath();
        ctx.arc(x + cellSize/2, y + cellSize/2, size/2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    function drawDeadCell(row, col) {
        const neighbors = countNeighbors(row, col);
        if (neighbors > 0) {
            const x = col * cellSize;
            const y = row * cellSize;
            const alpha = Math.min(neighbors * 0.1, 0.3);
            
            ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
            ctx.fillRect(x + cellSize/4, y + cellSize/4, cellSize/2, cellSize/2);
        }
    }

    function updateGrid() {
        
        const newGrid = Array.from({ length: numRows }, () => Array(numCols).fill(false));
        const newCellAge = Array.from({ length: numRows }, () => Array(numCols).fill(0));
        
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                const neighbors = countNeighbors(i, j);
                const currentAge = cellAge[i][j];
                
                if (grid[i][j] && (neighbors === 2 || neighbors === 3)) {
                    newGrid[i][j] = true;
                    newCellAge[i][j] = currentAge + 1;
                } else if (!grid[i][j] && neighbors === 3) {
                    newGrid[i][j] = true;
                    newCellAge[i][j] = 1;
                    createBirthEffect(i, j);
                } else if (grid[i][j]) {
                    createDeathEffect(i, j);
                }
            }
        }
        
        grid = newGrid;
        cellAge = newCellAge;
    }

    function createBirthEffect(row, col) {
        const x = col * cellSize + cellSize/2;
        const y = row * cellSize + cellSize/2;
        
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                ctx.save();
                ctx.globalAlpha = 1 - (i * 0.2);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, i * 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }, i * 50);
        }
    }

    function createDeathEffect(row, col) {
        const x = col * cellSize + cellSize/2;
        const y = row * cellSize + cellSize/2;
        
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                ctx.save();
                ctx.globalAlpha = 0.7 - (i * 0.2);
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(x + (Math.random() - 0.5) * 6, y + (Math.random() - 0.5) * 6, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }, i * 30);
        }
    }

    function countNeighbors(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                const newRow = row + i;
                const newCol = col + j;
                if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols && grid[newRow][newCol]) {
                    count++;
                }
            }
        }
        return count;
    }

    function initGridRandom() {
        for (let i = 0; i < numRows; i++) {
            for (let j = 0; j < numCols; j++) {
                if (Math.random() < 0.3) {
                    grid[i][j] = true;
                    cellAge[i][j] = Math.floor(Math.random() * 10);
                }
            }
        }
    }


    function startGame() {
        initGridRandom();
        
        const gameLoop = () => {
            updateGrid();
            drawGrid();
            requestAnimationFrame(gameLoop);
        };
        
        gameLoop();
    }

    window.onload = function() {
        startGame();
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            const newNumRows = Math.floor(canvas.height / cellSize);
            const newNumCols = Math.floor(canvas.width / cellSize);
            
            if (newNumRows !== numRows || newNumCols !== numCols) {
                location.reload();
            }
        });
        
        setInterval(() => {
            updateGrid();
        }, 120);
    };
</script>
</body>
</html>
